# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

# Script copyright (C) Wilhelm Kovatch

import bpy, bmesh
from .file_io import BinaryFileHelper

class BINReader:
    def __init__(self, filepath):
        self.filepath = filepath

    def read(self):
        self.file = BinaryFileHelper(self.filepath, 'rb')
        header = self.file.read_uint32()
        expected_header = int.from_bytes(b'km2B', 'little')
        if header != expected_header: raise Exception("not a .bin file generated by km2 City Builder")
        header2 = self.file.read_string()
        if header2 != "MidtownMadness2": raise Exception("not a .bin file generated by km2 City Builder with the Midtown Madness 2 core")
        num_elems = self.file.read_uint32()
        win = bpy.context.window_manager
        win.progress_begin(0, 100)
        for i in range(num_elems):
            #read the data
            is_mesh = self.file.read_byte() > 0
            name = self.file.read_string()
            num_properties = self.file.read_uint32()
            raw_properties = list(self.file.read_string() for j in range(num_properties * 2))
            num_verts = self.file.read_uint32()
            verts = list(self.file.read_vec3() for j in range(num_verts))
            num_indices = self.file.read_uint32()
            if is_mesh:
                indices = []
                for j in range(num_indices):
                    num_sub_indices = self.file.read_uint32()
                    indices.append(list(self.file.read_uint16() for i in range(num_sub_indices)))
                normals = list(self.file.read_vec3() for j in range(num_verts))
                uvs = list(self.file.read_vec2() for j in range(num_verts))
            else:
                indices = list(self.file.read_uint16() for j in range(num_indices))
                normals = None
                uvs = None
            num_mats = self.file.read_uint32()
            materials = list(self.file.read_string() for j in range(num_mats))
            transformed = self.file.read_byte()
            if transformed > 0:
                pos = self.file.read_vec3()
                scale = self.file.read_vec3()
                rot = self.file.read_quaternion()
            
            #create the object
            name_parts = name.split(".")
            if num_verts > 0:
                mesh = bpy.data.meshes.new(name_parts[0])
                obj = bpy.data.objects.new(name_parts[0], mesh)
                obj["is_mesh"] = is_mesh
                bm = bmesh.new()
                bm.from_mesh(mesh)
                bm.verts.ensure_lookup_table()
                bpy.context.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bm_verts = list(bm.verts.new(verts[j]) for j in range(num_verts))
                if is_mesh:
                    #normals
                    bm.verts.ensure_lookup_table()
                    for i in range(len(verts)):
                        bm.verts[i].normal = normals[i]
                    #faces with uvs and material
                    uv_layer = bm.loops.layers.uv.verify()
                    for k in range(num_indices):
                        inds = indices[k]
                        for j in range(0, len(indices[k]), 3):
                            try:
                                face = bm.faces.new((bm_verts[inds[j]], bm_verts[inds[j + 1]], bm_verts[inds[j + 2]]))
                                #no material otherwise import in Blender slows down a lot
                                for loop in face.loops:
                                    loop[uv_layer].uv = uvs[loop.vert.index]
                            except:
                                print("Warning: found duplicate face")
                else:
                    for j in range(0, num_indices, 3):
                        try:
                            bm.faces.new((bm_verts[indices[j]], bm_verts[indices[j + 1]], bm_verts[indices[j + 2]]))
                        except:
                            print("Warning: found duplicate face")
            else:
                obj = bpy.data.objects.new(name_parts[0], None)
                bpy.context.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
            for j in range(num_mats):
                obj["texture" + str(j)] = materials[j]
            if transformed > 0:
                obj.rotation_mode = 'QUATERNION'
                obj.rotation_quaternion = rot
                obj.scale = scale
                obj.location = pos
            if num_verts > 0:
                bm.to_mesh(mesh)
                bm.free()
            objtype = name_parts[0].split("_")[-1]
            for pi in  range(0, len(raw_properties), 2):
                p_key = raw_properties[pi]
                p_value = raw_properties[pi + 1]
                obj[p_key] = p_value
            if i % 100 == 0:
                print(str(round(i/num_elems*100)) + "% done")
                win.progress_update(round(i/num_elems*100))

        print("BIN file imported!")
        win.progress_end()
        self.file.close()
